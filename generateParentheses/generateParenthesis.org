#+TITLE:22. 括号生成
* 22. 括号生成
** 题目描述

给出 =n= 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

例如，
#+begin_example
给出 n = 3，生成结果为：

[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]

#+end_example

** 题解

*** 方法一：暴力法
**** 思路
我们可以生成所有  2^{2n} 个 '(' 和 ')' 字符构成的序列。然后，我们将检查
每一个是否有效。

**** 算法
为了生成所有序列，我们使用递归。长度为 n 的序列就是 '(' 加上所有长度为
n-1 的序列，以及 ')' 加上所有长度为 n-1 的序列。

为了检查序列是否为有效的，我们会跟踪 平衡，也就是左括号的数量减去右括
号的数量的净值。如果这个值始终小于零或者不以零结束，该序列就是无效的，
否则它是有效的。

**** 复杂度分析
时间复杂度：O(2^{2n}n) ，对于 2^{2n} 个序列中的每一个，我们用于建立和
验证该序列的复杂度为 O(n)。

空间复杂度：O(2^{2n}n) ，简单地，每个序列都视作是有效的。请参见 方法三
以获得更严格的渐近界限。

#+BEGIN_SRC java
  class Solution {
      public List<String> generateParenthesis(int n) {
          List<String> combinations = new ArrayList();
          generateAll(new char[2 * n], 0, combinations);
          return combinations;
      }

      public void generateAll(char[] current, int pos, List<String> result) {
          if (pos == current.length) {
              if (valid(current))
                  result.add(new String(current));
          } else {
              current[pos] = '(';
              generateAll(current, pos+1, result);
              current[pos] = ')';
              generateAll(current, pos+1, result);
          }
      }

      public boolean valid(char[] current) {
          int balance = 0;
          for (char c: current) {
              if (c == '(') balance++;
              else balance--;
              if (balance < 0) return false;
          }
          return (balance == 0);
      }
  }
#+END_SRC

*** 方法二：回溯法

**** 思路和算法

只有在我们知道序列仍然保持有效时才添加 '(' or ')'，而不是像 方法一 那
样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到
这一点，

如果我们还剩一个位置，我们可以开始放一个左括号。 如果它不超过左括号的
数量，我们可以放一个右括号。
